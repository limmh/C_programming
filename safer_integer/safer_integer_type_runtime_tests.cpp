/* Modified based on the content generated by GitHub Copilot */

#include <stdio.h>

#define SAFER_INTEGER_INCLUDE_SOURCE_FILE_INFO
#include "safer_integer_type.hpp"

typedef safer_integer::integer_type<safer_integer::DIP::bool_type, safer_integer::DIP> bool_type;
typedef safer_integer::integer_type<safer_integer::DIP::char_type, safer_integer::DIP> char_type;
typedef safer_integer::integer_type<safer_integer::DIP::schar_type, safer_integer::DIP> schar_type;
typedef safer_integer::integer_type<safer_integer::DIP::uchar_type, safer_integer::DIP> uchar_type;
typedef safer_integer::integer_type<safer_integer::DIP::short_type, safer_integer::DIP> short_type;
typedef safer_integer::integer_type<safer_integer::DIP::ushort_type, safer_integer::DIP> ushort_type;
typedef safer_integer::integer_type<safer_integer::DIP::int_type, safer_integer::DIP> int_type;
typedef safer_integer::integer_type<safer_integer::DIP::uint_type, safer_integer::DIP> uint_type;
typedef safer_integer::integer_type<safer_integer::DIP::long_type, safer_integer::DIP> long_type;
typedef safer_integer::integer_type<safer_integer::DIP::ulong_type, safer_integer::DIP> ulong_type;
typedef safer_integer::integer_type<safer_integer::DIP::llong_type, safer_integer::DIP> llong_type;
typedef safer_integer::integer_type<safer_integer::DIP::ullong_type, safer_integer::DIP> ullong_type;

void test_sum_of_series(int n) {
	DEFINE_SAFER_INTEGER(int_type, sum, 0);
	for (DEFINE_SAFER_INTEGER(int_type, i, 1); i <= n; ++i) {
		sum += i;
	}
	printf("Sum of 1..%d = %d\n", n, static_cast<int>(sum));
}

void test_factorial(int n) {
	DEFINE_SAFER_INTEGER(int_type, result, 1);
	for (DEFINE_SAFER_INTEGER(int_type, i, 2); i <= n; ++i) {
		result *= i;
	}
	printf("Factorial of %d = %d\n", n, static_cast<int>(result));
}

int test_power(int base, int exponent) {
	DEFINE_SAFER_INTEGER(int_type, result, 1);
	for (DEFINE_SAFER_INTEGER(int_type, i, 0); i < exponent; ++i) {
		result *= base;
	}
	printf("%d ^ %d = %d\n", base, exponent, static_cast<int>(result));
	return result;
}

int test_binary_search(const int *arr, int size, int target) {
	DEFINE_SAFER_INTEGER(int_type, left, 0);
	DEFINE_SAFER_INTEGER(int_type, right, int_type(size) - 1);
	DEFINE_SAFER_INTEGER(int_type, mid, -1);
	while (left <= right) {
		mid = (left + right) / 2;
		if (arr[mid] == target) {
			return static_cast<int>(mid);
		} else if (arr[mid] < target) {
			left = int_type(mid) + 1;
		} else {
			right = int_type(mid) - 1;
		}
	}
	return static_cast<int>(mid);
}

void test_integer_overflow_1(void) {
	const DEFINE_SAFER_INTEGER(int_type, a, INT_MAX);
	const DEFINE_SAFER_INTEGER(int_type, b, 1);
	int_type result = a + b;
	printf("Overflow test: INT_MAX + 1 = %d\n", static_cast<int>(result));
}

void test_integer_overflow_2(void) {
	const DEFINE_SAFER_INTEGER(int_type, a, INT_MIN);
	const DEFINE_SAFER_INTEGER(int_type, b, 1);
	int_type result = a - b;
	printf("Underflow test: INT_MIN - 1 = %d\n", static_cast<int>(result));
}

void test_integer_division_by_zero(void) {
	const DEFINE_SAFER_INTEGER(int_type, a, 1);
	const DEFINE_SAFER_INTEGER(int_type, b, 0);
	int_type result = a / b;
	printf("The result of division by zero is undefined. The result (%d) shall not be used.\n", static_cast<int>(result));
}

void test_division_of_minimum_integer_value_by_minus_one(void) {
	const DEFINE_SAFER_INTEGER(int_type, a, INT_MIN);
	const DEFINE_SAFER_INTEGER(int_type, b, -1);
	int_type result = a / b;
	printf("The result of dvision %d by %d is %d.\n", static_cast<int>(a), static_cast<int>(b), static_cast<int>(result));
}

int main(void) {
	printf("Testing sum of series...\n");
	test_sum_of_series(100);

	printf("Testing factorial...\n");
	test_factorial(13); // 13! overflows 32-bit int

	printf("Testing integer power...\n");
	test_power(2, 31); // 2^31 overflows 32-bit int

	printf("Testing binary search...\n");
	int arr[10];
	for (int i = 0; i < 10; ++i) arr[i] = i * 3;
	int idx = test_binary_search(arr, 10, 9);
	printf("Binary search for 9 in arr: %s (index %d)\n", (idx >= 0 ? "found" : "not found"), idx);

	printf("Testing integer overflow...\n");
	test_integer_overflow_1();

	printf("Testing integer underflow...\n");
	test_integer_overflow_2();

	printf("Testing division by zero...\n");
	test_integer_division_by_zero();

	printf("Testing division of minimum integer value (%d) by -1...\n", INT_MIN);
	test_division_of_minimum_integer_value_by_minus_one();
	
	// You can add more tests for other types: int8_t, uint16_t, etc., using macros di8add, du16mul, etc.
	return 0;
}
